import React, { forwardRef, useRef, useEffect, useState, useImperativeHandle } from 'react';
import { DataSet } from 'vis-data';
import { Network } from 'vis-network';
import { isEqual, defaultsDeep, cloneDeep, intersectionWith, differenceWith } from 'lodash-es';
import 'vis-network/styles/vis-network.css';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = ["graph", "events", "getNetwork", "options"];
/**
 * Keeps the value the same permanently.
 * Useful over refs especially in instances where the function creation variant is used
 */

function useSealedState(value) {
  var _useState = useState(value),
      state = _useState[0];

  return state;
}
/**
 * https://github.com/crubier/react-graph-vis/commit/68bf2e27b2046d6c0bb8b334c2cf974d23443264
 */


var diff = function diff(current, next, field) {
  if (field === void 0) {
    field = 'id';
  }

  var nextIds = new Set(next.map(function (item) {
    return item[field];
  }));
  var removed = current.filter(function (item) {
    return !nextIds.has(item[field]);
  });
  var unchanged = intersectionWith(next, current, isEqual);
  var updated = differenceWith(intersectionWith(next, current, function (a, b) {
    return a[field] === b[field];
  }), unchanged, isEqual);
  var added = differenceWith(differenceWith(next, current, isEqual), updated, isEqual);
  return {
    removed: removed,
    unchanged: unchanged,
    updated: updated,
    added: added
  };
};

var defaultOptions = {
  physics: {
    stabilization: false
  },
  autoResize: false,
  edges: {
    smooth: false,
    color: '#000000',
    width: 0.5,
    arrows: {
      to: {
        enabled: true,
        scaleFactor: 0.5
      }
    }
  }
};

function useResizeObserver(ref, callback) {
  useEffect(function () {
    // Create an observer instance linked to the callback function
    if (ref.current) {
      var observer = new ResizeObserver(callback); // Start observing the target node for configured mutations

      observer.observe(ref.current);
      return function () {
        observer.disconnect();
      };
    }

    return;
  }, [callback, ref]);
}

var VisGraph = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var graph = _ref.graph,
      events = _ref.events,
      getNetwork = _ref.getNetwork,
      propOptions = _ref.options,
      props = _objectWithoutPropertiesLoose(_ref, _excluded);

  var container = useRef(null);
  var edges = useSealedState(function () {
    return new DataSet(graph.edges);
  });
  var nodes = useSealedState(function () {
    return new DataSet(graph.nodes);
  });
  var initialOptions = useSealedState(propOptions);
  var prevNodes = useRef(graph.nodes);
  var prevEdges = useRef(graph.edges);
  useEffect(function () {
    if (isEqual(graph.nodes, prevNodes.current)) {
      return; // No change!
    }

    var _diff = diff(prevNodes.current, graph.nodes),
        added = _diff.added,
        removed = _diff.removed,
        updated = _diff.updated;

    nodes.remove(removed);
    nodes.add(added);
    nodes.update(updated);
    prevNodes.current = graph.nodes;
  }, [graph.nodes, nodes]);
  useEffect(function () {
    if (isEqual(graph.edges, prevEdges.current)) {
      return; // No change!
    }

    var _diff2 = diff(prevEdges.current, graph.edges),
        added = _diff2.added,
        removed = _diff2.removed,
        updated = _diff2.updated;

    edges.remove(removed);
    edges.add(added);
    edges.update(updated);
    prevEdges.current = graph.edges;
  }, [graph.edges, edges]);

  var _useState2 = useState(),
      network = _useState2[0],
      setNetwork = _useState2[1];

  useImperativeHandle(ref, function () {
    return network;
  }, [network]);
  useEffect(function () {
    if (!network || !events) {
      return function () {};
    } // Add user provied events to network


    for (var _i = 0, _Object$entries = Object.entries(events); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          eventName = _Object$entries$_i[0],
          callback = _Object$entries$_i[1];

      if (callback) {
        network.on(eventName, callback);
      }
    }

    return function () {
      for (var _i2 = 0, _Object$entries2 = Object.entries(events); _i2 < _Object$entries2.length; _i2++) {
        var _Object$entries2$_i = _Object$entries2[_i2],
            _eventName = _Object$entries2$_i[0],
            _callback = _Object$entries2$_i[1];

        if (_callback) {
          network.off(_eventName, _callback);
        }
      }
    };
  }, [events, network]);
  useEffect(function () {
    if (!network || !propOptions) {
      return;
    }

    try {
      network.setOptions(propOptions);
    } catch (error) {
      // Throws when it hot reloads... Yay
      if (process.env.NODE_ENV !== 'development') {
        // Still throw it in prod where there's no hot reload
        throw error;
      }
    }
  }, [network, propOptions]);
  useEffect(function () {
    // Creating the network has to be done in a useEffect because it needs access to a ref
    // merge user provied options with our default ones
    // defaultsDeep mutates the host object
    var mergedOptions = defaultsDeep(cloneDeep(initialOptions), defaultOptions);
    var newNetwork = new Network(container.current, {
      edges: edges,
      nodes: nodes
    }, mergedOptions);
    setNetwork(newNetwork);

    if (getNetwork) {
      getNetwork(newNetwork);
    }

    return function () {
      // Cleanup the network on component unmount
      newNetwork.destroy();
    };
  }, [edges, initialOptions, nodes]); //resize network on window resize

  function onContainerResize() {
    if (network) {
      network.redraw();
    }
  }

  useResizeObserver(container, onContainerResize);
  return React.createElement("div", Object.assign({
    style: {
      width: '100%',
      height: '100%'
    },
    ref: container
  }, props));
});

export default VisGraph;
//# sourceMappingURL=react-vis-graph-wrapper.esm.js.map
