{"ast":null,"code":"import React, { forwardRef, useRef, useEffect, useState, useImperativeHandle } from 'react';\nimport { DataSet } from 'vis-data';\nimport { Network } from 'vis-network';\nimport { isEqual, defaultsDeep, cloneDeep, intersectionWith, differenceWith } from 'lodash-es';\nimport 'vis-network/styles/vis-network.css';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"graph\", \"events\", \"getNetwork\", \"options\"];\n/**\r\n * Keeps the value the same permanently.\r\n * Useful over refs especially in instances where the function creation variant is used\r\n */\n\nfunction useSealedState(value) {\n  var _useState = useState(value),\n      state = _useState[0];\n\n  return state;\n}\n/**\r\n * https://github.com/crubier/react-graph-vis/commit/68bf2e27b2046d6c0bb8b334c2cf974d23443264\r\n */\n\n\nvar diff = function diff(current, next, field) {\n  if (field === void 0) {\n    field = 'id';\n  }\n\n  var nextIds = new Set(next.map(function (item) {\n    return item[field];\n  }));\n  var removed = current.filter(function (item) {\n    return !nextIds.has(item[field]);\n  });\n  var unchanged = intersectionWith(next, current, isEqual);\n  var updated = differenceWith(intersectionWith(next, current, function (a, b) {\n    return a[field] === b[field];\n  }), unchanged, isEqual);\n  var added = differenceWith(differenceWith(next, current, isEqual), updated, isEqual);\n  return {\n    removed: removed,\n    unchanged: unchanged,\n    updated: updated,\n    added: added\n  };\n};\n\nvar defaultOptions = {\n  physics: {\n    stabilization: false\n  },\n  autoResize: false,\n  edges: {\n    smooth: false,\n    color: '#000000',\n    width: 0.5,\n    arrows: {\n      to: {\n        enabled: true,\n        scaleFactor: 0.5\n      }\n    }\n  }\n};\n\nfunction useResizeObserver(ref, callback) {\n  useEffect(function () {\n    // Create an observer instance linked to the callback function\n    if (ref.current) {\n      var observer = new ResizeObserver(callback); // Start observing the target node for configured mutations\n\n      observer.observe(ref.current);\n      return function () {\n        observer.disconnect();\n      };\n    }\n\n    return;\n  }, [callback, ref]);\n}\n\nvar VisGraph = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var graph = _ref.graph,\n      events = _ref.events,\n      getNetwork = _ref.getNetwork,\n      propOptions = _ref.options,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var container = useRef(null);\n  var edges = useSealedState(function () {\n    return new DataSet(graph.edges);\n  });\n  var nodes = useSealedState(function () {\n    return new DataSet(graph.nodes);\n  });\n  var initialOptions = useSealedState(propOptions);\n  var prevNodes = useRef(graph.nodes);\n  var prevEdges = useRef(graph.edges);\n  useEffect(function () {\n    if (isEqual(graph.nodes, prevNodes.current)) {\n      return; // No change!\n    }\n\n    var _diff = diff(prevNodes.current, graph.nodes),\n        added = _diff.added,\n        removed = _diff.removed,\n        updated = _diff.updated;\n\n    nodes.remove(removed);\n    nodes.add(added);\n    nodes.update(updated);\n    prevNodes.current = graph.nodes;\n  }, [graph.nodes, nodes]);\n  useEffect(function () {\n    if (isEqual(graph.edges, prevEdges.current)) {\n      return; // No change!\n    }\n\n    var _diff2 = diff(prevEdges.current, graph.edges),\n        added = _diff2.added,\n        removed = _diff2.removed,\n        updated = _diff2.updated;\n\n    edges.remove(removed);\n    edges.add(added);\n    edges.update(updated);\n    prevEdges.current = graph.edges;\n  }, [graph.edges, edges]);\n\n  var _useState2 = useState(),\n      network = _useState2[0],\n      setNetwork = _useState2[1];\n\n  useImperativeHandle(ref, function () {\n    return network;\n  }, [network]);\n  useEffect(function () {\n    if (!network || !events) {\n      return function () {};\n    } // Add user provied events to network\n\n\n    for (var _i = 0, _Object$entries = Object.entries(events); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          eventName = _Object$entries$_i[0],\n          callback = _Object$entries$_i[1];\n\n      if (callback) {\n        network.on(eventName, callback);\n      }\n    }\n\n    return function () {\n      for (var _i2 = 0, _Object$entries2 = Object.entries(events); _i2 < _Object$entries2.length; _i2++) {\n        var _Object$entries2$_i = _Object$entries2[_i2],\n            _eventName = _Object$entries2$_i[0],\n            _callback = _Object$entries2$_i[1];\n\n        if (_callback) {\n          network.off(_eventName, _callback);\n        }\n      }\n    };\n  }, [events, network]);\n  useEffect(function () {\n    if (!network || !propOptions) {\n      return;\n    }\n\n    try {\n      network.setOptions(propOptions);\n    } catch (error) {\n      // Throws when it hot reloads... Yay\n      if (process.env.NODE_ENV !== 'development') {\n        // Still throw it in prod where there's no hot reload\n        throw error;\n      }\n    }\n  }, [network, propOptions]);\n  useEffect(function () {\n    // Creating the network has to be done in a useEffect because it needs access to a ref\n    // merge user provied options with our default ones\n    // defaultsDeep mutates the host object\n    var mergedOptions = defaultsDeep(cloneDeep(initialOptions), defaultOptions);\n    var newNetwork = new Network(container.current, {\n      edges: edges,\n      nodes: nodes\n    }, mergedOptions);\n    setNetwork(newNetwork);\n\n    if (getNetwork) {\n      getNetwork(newNetwork);\n    }\n\n    return function () {\n      // Cleanup the network on component unmount\n      newNetwork.destroy();\n    };\n  }, [edges, initialOptions, nodes]); //resize network on window resize\n\n  function onContainerResize() {\n    if (network) {\n      network.redraw();\n    }\n  }\n\n  useResizeObserver(container, onContainerResize);\n  return React.createElement(\"div\", Object.assign({\n    style: {\n      width: '100%',\n      height: '100%'\n    },\n    ref: container\n  }, props));\n});\nexport default VisGraph;","map":{"version":3,"mappings":"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","names":["useSealedState","value","useState","state","diff","current","next","field","nextIds","Set","map","item","removed","filter","has","unchanged","intersectionWith","isEqual","updated","differenceWith","a","b","added","defaultOptions","physics","stabilization","autoResize","edges","smooth","color","width","arrows","to","enabled","scaleFactor","useResizeObserver","ref","callback","useEffect","observer","ResizeObserver","observe","disconnect","VisGraph","forwardRef","graph","events","getNetwork","propOptions","options","props","container","useRef","DataSet","nodes","initialOptions","prevNodes","prevEdges","remove","add","update","network","setNetwork","useImperativeHandle","Object","entries","eventName","on","off","setOptions","error","process","env","NODE_ENV","mergedOptions","defaultsDeep","cloneDeep","newNetwork","Network","destroy","onContainerResize","redraw","React","style","height"],"sources":["../src/index.tsx"],"sourcesContent":["import React, {\n  forwardRef,\n  HTMLAttributes,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport { DataSet } from 'vis-data';\nimport {\n  Network,\n  Edge,\n  Node,\n  Options,\n  NetworkEvents,\n  IdType,\n} from 'vis-network';\nimport {\n  differenceWith,\n  intersectionWith,\n  isEqual,\n  defaultsDeep,\n  cloneDeep,\n} from 'lodash';\n\nimport 'vis-network/styles/vis-network.css';\n\nexport type {\n  Network, Edge, Node, Options, NetworkEvents, IdType, \n};\n\nexport type GraphEvents = Partial<\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nRecord<NetworkEvents, (params?: any) => void>\n>;\n\nexport interface GraphData {\n  nodes: Node[];\n  edges: Edge[];\n}\n\nexport interface NetworkGraphProps {\n  graph: GraphData;\n  options?: Options;\n  getNetwork?: (network: any) => void;\n  events?: GraphEvents;\n  style?: React.CSSProperties;\n  className?: string;\n}\n/**\n * Keeps the value the same permanently.\n * Useful over refs especially in instances where the function creation variant is used\n */\nfunction useSealedState<T>(value: T | (() => T)) {\n  const [state] = useState(value);\n  return state;\n}\n\n/**\n * https://github.com/crubier/react-graph-vis/commit/68bf2e27b2046d6c0bb8b334c2cf974d23443264\n */\nconst diff = <T extends { id?: IdType }>(\n  current: T[],\n  next: T[],\n  field: keyof T = 'id',\n) => {\n  const nextIds = new Set(next.map((item) => item[field]));\n  const removed = current.filter((item) => !nextIds.has(item[field]));\n\n  const unchanged = intersectionWith(next, current, isEqual);\n\n  const updated = differenceWith(\n    intersectionWith(next, current, (a, b) => a[field] === b[field]),\n    unchanged,\n    isEqual,\n  );\n\n  const added = differenceWith(\n    differenceWith(next, current, isEqual),\n    updated,\n    isEqual,\n  );\n\n  return {\n    removed,\n    unchanged,\n    updated,\n    added,\n  };\n};\n\nconst defaultOptions = {\n  physics: {\n    stabilization: false,\n  },\n  autoResize: false,\n  edges: {\n    smooth: false,\n    color: '#000000',\n    width: 0.5,\n    arrows: {\n      to: {\n        enabled: true,\n        scaleFactor: 0.5,\n      },\n    },\n  },\n};\n\nfunction useResizeObserver(\n  ref: React.MutableRefObject<HTMLElement | null>,\n  callback: ResizeObserverCallback,\n): void {\n  useEffect(() => {\n    // Create an observer instance linked to the callback function\n    if (ref.current) {\n      const observer = new ResizeObserver(callback);\n\n      // Start observing the target node for configured mutations\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n    return;\n  }, [callback, ref]);\n}\n\nconst VisGraph = forwardRef<\nNetwork | undefined,\nNetworkGraphProps & HTMLAttributes<HTMLDivElement>\n>(({ graph, events, getNetwork, options: propOptions, ...props }, ref) => {\n  const container = useRef<HTMLDivElement>(null);\n  const edges = useSealedState(() => new DataSet<Edge>(graph.edges));\n  const nodes = useSealedState(() => new DataSet<Node>(graph.nodes));\n  const initialOptions = useSealedState(propOptions);\n\n  const prevNodes = useRef(graph.nodes);\n  const prevEdges = useRef(graph.edges);\n  useEffect(() => {\n    if (isEqual(graph.nodes, prevNodes.current)) {\n      return; // No change!\n    }\n    const { added, removed, updated } = diff(prevNodes.current, graph.nodes);\n\n    nodes.remove(removed);\n    nodes.add(added);\n    nodes.update(updated);\n    prevNodes.current = graph.nodes;\n  }, [graph.nodes, nodes]);\n\n  useEffect(() => {\n    if (isEqual(graph.edges, prevEdges.current)) {\n      return; // No change!\n    }\n    const { added, removed, updated } = diff(prevEdges.current, graph.edges);\n\n    edges.remove(removed);\n    edges.add(added);\n    edges.update(updated);\n    prevEdges.current = graph.edges;\n  }, [graph.edges, edges]);\n  const [network, setNetwork] = useState<Network>();\n\n  useImperativeHandle(ref, () => network, [network]);\n\n  useEffect(() => {\n    if (!network || !events) {\n      return () => {};\n    }\n    // Add user provied events to network\n    for (const [eventName, callback] of Object.entries(events)) {\n      if (callback) {\n        network.on(eventName as NetworkEvents, callback);\n      }\n    }\n    return () => {\n      for (const [eventName, callback] of Object.entries(events)) {\n        if (callback) {\n          network.off(eventName as NetworkEvents, callback);\n        }\n      }\n    };\n  }, [events, network]);\n\n  useEffect(() => {\n    if (!network || !propOptions) {\n      return;\n    }\n    try {\n      network.setOptions(propOptions);\n    } catch (error) {\n      // Throws when it hot reloads... Yay\n      if (process.env.NODE_ENV !== 'development') {\n        // Still throw it in prod where there's no hot reload\n        throw error;\n      }\n    }\n  }, [network, propOptions]);\n\n  useEffect(() => {\n    // Creating the network has to be done in a useEffect because it needs access to a ref\n\n    // merge user provied options with our default ones\n    // defaultsDeep mutates the host object\n    const mergedOptions = defaultsDeep(\n      cloneDeep(initialOptions),\n      defaultOptions,\n    );\n    const newNetwork = new Network(\n      container.current as HTMLElement,\n      { edges, nodes },\n      mergedOptions,\n    );\n    setNetwork(newNetwork);\n    if(getNetwork) {\n      getNetwork(newNetwork)\n    }\n    return () => {\n      // Cleanup the network on component unmount\n      newNetwork.destroy();\n    };\n  }, [edges, initialOptions, nodes]);\n\n  //resize network on window resize\n  function onContainerResize(){\n    if (network){\n      network.redraw();\n    }\n  }\n\n  useResizeObserver(container, onContainerResize);\n\n  return <div style={ { width: '100%', height: '100%' }} ref={container} {...props} />;\n});\n\nexport default VisGraph;"]},"metadata":{},"sourceType":"module"}